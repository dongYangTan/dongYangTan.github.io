<!--
 * @Date: 2024-01-16 14:36:47
 * @LastEditors: 谭冬阳 tandongyang@youlai.cn
 * @LastEditTime: 2025-03-26 16:47:06
 * @FilePath: /dongYangTan.github.io/docs/web/react/README.md
-->

## 1. 如何实现组件懒加载
从 16.6.0 开始，React 提供了 lazy 和 Suspense 来实现懒加载。  
属性fallback表示在加载组件前，渲染的内容。
```
import React, { lazy, Suspense } from 'react';
const OtherComponent = lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <OtherComponent />
    </Suspense>
  );
}
```

## 2. 什么是虚拟DOM？
虚拟 DOM 是 React 中的一个概念，其中创建实际 DOM（文档对象模型）的轻量级虚拟表示并将其存储在内存中。它是一种用于优化 Web 应用程序性能的编程技术。  
当 React 组件的数据或状态发生更改时，虚拟 DOM 会被更新，而不是直接操作真实 DOM。然后，虚拟 DOM 计算组件的先前状态和更新状态之间的差异，称为“比较”过程。  
一旦识别出差异，React 就会高效地仅更新真实 DOM 的必要部分以反映更改。这种方法最大限度地减少了实际 DOM 操作的数量，并提高了应用程序的整体性能。  
通过使用虚拟 DOM，React 提供了一种创建动态和交互式用户界面的方法，同时确保最佳效率和渲染速度

## 3. 虚拟 dom 有什么优点？真实 dom 和虚拟 dom，谁快？
Virtual DOM 是以对象的方式来描述真实 dom 对象的，那么在做一些 update 的时候，可以在内存中进行数据比对，减少对真实 dom 的操作减少浏览器重排重绘的次数，减少浏览器的压力，提高程序的性能，并且因为 diff 算法的差异比较，记录了差异部分，那么在开发中就会帮助程序员减少对差异部分心智负担，提高了开发效率。  
虚拟 dom 好多这么多，渲染速度上是不是比直接操作真实 dom 快呢？并不是。虚拟 dom 增加了一层内存运算，然后才操作真实 dom，将数据渲染到页面上。渲染上肯定会慢上一些。虽然虚拟 dom 的缺点在初始化时增加了内存运算，增加了首页的渲染时间，但是运算时间是以毫秒级别或微秒级别算出的，对用户体验影响并不是很大。  
## 4. 什么是合成事件，与原生事件有什么区别？
React 中所有触发的事件，都是自己在其内部封装了一套事件机制。目的是为了实现全浏览器的一致性，抹平不同浏览器之间的差异性。  
在 React17 之前，React 是把事件委托在 document 上的，React17 及以后版本不再把事件委托在 document 上，而是委托在挂载的容器上。React 合成事件采用的是事件冒泡机制，当在某具体元素上触发事件时，等冒泡到顶部被挂载事件的那个元素时，才会真正地执行事件。  
而原生事件，当某具体元素触发事件时，会立刻执行该事件。因此若要比较事件触发的先后时机时，原生事件会先执行，React 合成事件会后执行。  
## 5. key 的作用是什么？
key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。  
当组件刷新时，React 内部会根据 key 和元素的 type，来对比元素是否发生了变化。若选做 key 的数据有问题，可能会在更新的过程中产生异常。  
## 6. 多次执行 useState()，会触发多次更新吗？
在 React18 中，无论是多个 useState()的 hook，还是操作（dispatch）多次的数据。只要他们在同一优先级，React 就会将他们合并到一起操作，最后再更新数据。  
这是基于 React18 的批处理机制。React 将多个状态更新分组到一个重新渲染中以获得更好的性能。（将多次 setstate 事件合并）；在 v18 之前只在事件处理函数中实现了批处理，在 v18 中所有更新都将自动批处理，包括 promise 链、setTimeout 等异步代码以及原生事件处理函数； 
## 7. 基于 React 框架的特点，可以有哪些优化措施？
- 使用 React.lazy 和 Suspense 将页面设置为懒加载，避免 js 文件过大；  
- 使用 SSR 同构直出技术，提高首屏的渲染速度；  
- 使用 useCallback 和 useMemo 缓存函数或变量；使用 React.memo 缓存组件；  
- 尽量调整样式或 className 的变动，减少 jsx 元素上的变动，尽量使用与元素相关的字段作为 key，可以减少 diff 的时间（React 会尽量复用之前的节点，若 jsx 元素发生变动，就需要重新创建节点）;  
- 对于不需要产生页面变动的数据，可以放到 useRef()中；  
## 8. 在 React 中如何处理事件
- *绑定事件：*在JSX中，你可以将事件处理函数与元素的特定事件属性进行绑定，例如onClick、onChange等。这通过将事件处理函数作为属性值来实现   
- *事件委派：*React使用了一种称为"事件委派"的技术，它将所有事件监听器添加到文档的最上层，而不是直接将事件监听器添加到每个单独的元素上。这样做的好处是减少了事件监听器的数量，提高了性能和内存使用效率。React通过事件冒泡来处理事件，当元素触发事件时，事件会向上冒泡到文档根节点，在那里React会根据当前组件的事件绑定来决定调用哪个事件处理函数。  
- *合成事件：*当元素触发事件时，React会创建一个"合成事件"对象。合成事件是一个跨浏览器可用的React封装的事件对象，它提供了统一的接口来处理不同浏览器之间的差异。合成事件对象包含有关事件的详细信息，例如事件类型、目标元素、键盘按键、鼠标位置等。它也提供了一些方法，例如preventDefault()用于阻止默认行为，stopPropagation()用于停止事件冒泡等。  
- *事件处理函数调用：*当合成事件对象被创建后，React会调用相应的事件处理函数并将合成事件对象作为参数传递给它。在事件处理函数内部，你可以访问合成事件对象，通过它来获取事件的相关属性和执行相关操作。  
- *组件状态更新：*在事件处理函数中，你可以使用setState方法来更新组件的状态。通过更新状态，React会重新渲染组件，并根据新的状态值更新相应的视图。这使得你可以根据事件的触发来动态地更新组件的显示内容或行为。  
**通过这些内部原理，React实现了高效的事件处理机制，提供了一致的跨浏览器行为，并使开发者能够方便地处理和响应用户交互。**


## 9. 什么是高阶组件？
高阶组件(HOC)是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为纯组件，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为。  
**HOC 可以用于以下许多用例**   
* 代码重用、逻辑和引导抽象  
* 渲染劫持  
* state 抽象和操作  
* props 处理   


## 10. 通过调用 event.stopPropagation()，可以阻止事件继续向上层元素传播，从而避免不必要的事件触发和处理。
``` 
function handleChildClick(event) {
  event.stopPropagation(); // 阻止事件冒泡
  console.log('子元素被点击');
}
function handleParentClick() {
  console.log('父元素被点击');
}
<div onClick={handleParentClick}>
  <button onClick={handleChildClick}>子元素</button>
</div>
```  
在上述示例中，当点击子元素时，会触发子元素上的 handleChildClick 事件处理函数，并在控制台中打印出 '子元素被点击'。同时，由于调用了 event.stopPropagation()，父元素上的 handleParentClick 事件处理函数不会被触发，因此不会打印 '父元素被点击'。如果省略了 event.stopPropagation()，则点击子元素时会触发子元素和父元素上的事件处理函数，控制台会依次打印 '子元素被点击' 和 '父元素被点击'。


## 11. event.preventDefault(); // 阻止表单的默认提交行为
form表单调用 handleSubmit 函数并在函数内部调用 event.preventDefault() 阻止了表单的默认提交行为 在 handleSubmit 函数中自定义处理表单数据，而不会导致页面的刷新或跳转。


## 12. 受控组件和非受控组件区别是啥？
* 受控组件是 React 控制中的组件，并且是表单数据真实的唯一来源。  
* 非受控组件是由 DOM 处理表单数据的地方，而不是在 React 组件中。  

**尽管非受控组件通常更易于实现，因为只需使用refs即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。  这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式**


## 13. 什么是 React Fiber?
Fiber 是 React 16 中新的协调引擎或重新实现核心算法，用于支持虚拟DOM的增量渲染。React Fiber 的目标是提高其在动画、布局、手势等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。

## 14. 对React-Fiber的理解，它解决了什么问题？
React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿。  
为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。   
所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:  
* 分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验；  
* 给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。 


***核心思想:*** Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。

## 15. 哪些方法会触发 react 重新渲染?
* setState（）方法被调用
* 父组件重新渲染 **（如子不渲染可使用React.memo() 并且保证父传子的props不发生变化）**


## 16. 什么是React.memo()？
React.memo() 是一个高阶组件。如果组件总是以不变的道具渲染相同的内容，可以在某些情况下将其封装在 React.memo() 调用中以提高性能，从而记住渲染结果。这意味着 React 将使用上次渲染的结果，避免重新渲染。React.memo() 只影响对道具的更改。如果功能组件被封装在 React.memo 中并使用了 useState、useReducer 或 useContext，那么当状态或上下文发生变化时，它将被重新渲染。
```
import { memo } from 'react';
const MemoComponent = memo(MemoComponent = (props) => {
  // ...
});
```

## 17. React中可以在render访问refs吗？为什么？
不可以，render 阶段 DOM 还没有生成，无法获取 DOM。
## 18. 对 React context 的理解
在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了。 可以使用Context来实现跨层级的组件数据传递。
## 19. React.forwardRef是什么？它有什么作用？
React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。  
* 转发 refs 到 DOM 组件
* 在高阶组件中转发 refs  


## 20. 类组件与函数组件有什么异同？
#### 相同点：
组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。  
#### 不同点：
* 它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。  
* 之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。
* 性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。
* 从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。
* 类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。

## 21. React中setState的第二个参数作用是什么？
setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值

## 22. 你知道哪些React hooks？
* useState：用于管理功能组件中的状态。
* useEffect：用于在功能组件中执行副作用，例如获取数据或订阅事件。
* useContext：用于访问功能组件内的 React 上下文的值。
* useRef：用于创建对跨渲染持续存在的元素或值的可变引用。
* useCallback：用于记忆函数以防止不必要的重新渲染。
* useMemo：用于记忆值，通过缓存昂贵的计算来提高性能。
* useReducer：用于通过reducer函数管理状态，类似于Redux的工作原理。
* useLayoutEffect：与useEffect类似，但效果在所有DOM突变后同步运行。

## 23. useMemo 的用途是什么？它是如何工作的？
用于缓存和记忆计算结果。计算结果。useMemo 仅在任何依赖项的值发生变化时才会重新计算记忆值。这种优化有助于避免昂贵的计算。  
对于第一个参数，函数接受一个执行计算的回调，对于第二个参数，函数接受一个依赖关系数组，只有当至少一个依赖关系发生变化时，函数才会重新执行计算。  
```
const memoValue = useMemo(() => computeFunc(paramA, paramB), [paramA, paramB]);
```

## 24. useCallback 的用途是什么？它是如何工作的？
useCallback 钩子将返回回调的记忆化版本，只有当其中一个依赖项的值发生变化时，回调才会发生变化。 这在将回调传递给依赖链接平等性的优化子组件时非常有用，可以防止不必要的呈现
```
const callbackValue = useCallback(() => computeFunc(paramA, paramB), [paramA, paramB]);
```

## 25. useMemo 和 useCallback 有什么区别？
1、useMemo用于记忆计算结果，而useCallback用于记忆函数本身。  
2、useMemo如果依赖项未更改，则缓存计算值并在后续渲染时返回该值。  
3、useCallback缓存函数本身并返回相同的实例，除非依赖项已更改。  

## 26. 什么是React Fragment
从组件返回多个元素是 React 中的常见做法。片段允许形成子元素列表，而无需在 DOM 中创建不必要的节点。
```
<>
  <OneChild />
  <AnotherChild />
</>
// 或
<React.Fragment>
  <OneChild />
  <AnotherChild />
</React.Fragment>
```

## 27. 什么是React调和？
调和是 React 的一种算法，用于区分一棵元素树和另一棵元素树，以确定需要替换的部分。 调和是我们过去所说的虚拟 DOM 背后的算法。其定义听起来是这样的：当您渲染 React 应用程序时，描述应用程序的元素树会在预留内存中生成。然后，这棵树就会被包含在呈现环境中，例如，在浏览器应用程序中，它会被转化为一组 DOM 操作。应用状态更新时，会生成新的元素树。新的树会与之前的树进行比较，以便准确计算和启用重新绘制更新后的应用程序所需的操作。  

## 28. 如何跟踪功能组件中对象字段的变化？
需要使用 useEffect 钩子，并将对象的字段作为依赖数组传递。
```
useEffect(() => {
  console.log('Changed!')
}, [obj.someField])
```
## 29. 什么是SSR（服务器端渲染）？
服务器端渲染（SSR）是一种用于在服务器上渲染网页并将完全渲染后的网页发送到客户端显示的技术。它允许服务器生成网页的完整 HTML 标记，包括动态内容，并作为对请求的响应发送给客户端。  
在传统的客户端呈现方法中，客户端会收到一个最小的 HTML 页面，然后向服务器提出额外的数据和资源请求，用于在客户端呈现页面。这会导致初始页面加载时间变慢，并对搜索引擎优化（SEO）产生负面影响，因为搜索引擎爬虫很难索引 JavaScript 驱动的内容。  
使用 SSR 时，服务器通过执行必要的 JavaScript 代码来生成最终的 HTML，从而完成网页的渲染。这意味着客户端可以从服务器接收完全呈现的网页，从而减少了对额外资源请求的需求。SSR 可改善初始页面加载时间，并允许搜索引擎轻松索引内容，从而提高搜索引擎优化效果。  
SSR 常用于 React 的 Next.js 和 Vue.js 的 Nuxt.js 等框架和库中，以启用服务器端呈现功能。这些框架会为您处理服务器端呈现逻辑，从而更容易实现 SSR。

## 30. 使用SSR有什么好处？
**改善初始加载时间：** SSR 允许服务器向客户端发送完整呈现的 HTML 页面，从而减少客户端所需的处理量。这就改善了初始加载时间，因为用户可以更快地看到完整的页面。  
**有利于搜索引擎优化：**搜索引擎可以有效地抓取和索引 SSR 页面的内容，因为在初始响应中提供了完全呈现的 HTML。这就提高了搜索引擎的可见性，有助于获得更好的搜索排名。  
**可访问性：** SSR 可确保禁用 JavaScript 或使用辅助技术的用户可以访问内容。通过在服务器上生成 HTML，SSR 可为所有用户提供可靠、可访问的用户体验。  
**低带宽环境下的性能：** SSR 减少了客户端需要下载的数据量，因此有利于低带宽或高延迟环境中的用户。这对于移动用户或网络连接速度较慢的用户尤为重要。  
**虽然 SSR 具有这些优点，但必须注意的是，与客户端渲染方法相比，它可能会带来更多的服务器负载和维护复杂性。应仔细考虑缓存、可扩展性和服务器端呈现性能优化等因素。**


## 31. 什么是 linters？
Linters 是用于检查源代码是否存在潜在错误、错误、风格不一致和可维护性问题的工具。它们帮助执行编码标准并确保整个代码库的代码质量和一致性。  
Linters 的工作原理是扫描源代码并将其与一组预定义的规则或指南进行比较。这些规则可以包括语法和格式约定、最佳实践、潜在错误和代码异味。当 linter 发现违反规则时，它会生成警告或错误，突出显示需要注意的特定行或多行代码  

## 32. ES6 语法特性
1) 新增用于声明变量的关键字let、const  
2) 解构赋值  
3) 新增箭头函数定义函数的方式   
4) 模板字符串  
5) 扩展运算符  

## 33.  什么是jsx
JSX是一种JavaScript的语法扩展，用来声明 React 当中的元素。优点：1） JSX执行更快，因为在编译为JavaScript代码后进行了优化（JSX无法直接运行，需要webpack等工具转换为传统的JS）；2） JSX是类型安全的，在编译过程中就能发现错误；3） 使用JSX编写模板更简单快速； 
 

## 34. React的特点
1) 声明式设计  
2) 组件化  
3) 高效（通过虚拟DOM，最大限度减少与DOM的交互）  
4) 灵活  

## 35. react diff 原理
1) tree diff：把树形结构按照层级分解，只比较同级DOM节点。  
2) element diff：当节点属于同一层级时给每个单元添加唯一的key ，方便比较。   
3) component diff组件之间比较：React 只会匹配相同类型的组件。  

## 36. 什么是prop drilling，如何避免？
多层嵌套组件中，prop从源组件一层层的传递到深层嵌套组件，这叫做prop drilling。  
prop drilling的主要缺点是原本不需要数据的组件变得复杂且难以维护。为了避免prop drilling，一种常用的方法是使用React Context。

## 37. react路由模式有哪些？
路由存在history模式和hash模式。


## 38. 什么是Redux?
Redux是JS的可预测状态容器，用于全局的状态管理。
## 39. Redux 有哪些优点？
1) 结果的可预测性：因为Reducer是纯函数，如果将相同的state和action传递给Reducer则总是会产生相同的结果；
2) 易于调试：通过记录操作和状态，很容易理解编码错误
3) 可维护性：具有严格的结构，更容易理解。


## 40. Redux遵循的三个原则是什么？
1) 单一事实来源：整个应用的 state都被存储到一个状态树里面，并且这个状态树只存在于唯一的 store中；
2) state是只读的：state是只读的，唯一改变 state的方法就是触发 action；
3) 使用纯函数来执行修改：reducer是一个纯函数，它接收先前的state和action，并且返回一个新的state


## 41. 你对“单一事实来源”有什么理解？
Redux 中所有组件的状态都存储在Store中，并且它们从Store本身接收更新。单一状态树可以更容易地跟踪状态随时间的变化，并调试或检查程序。 

## 42. Redux 核心组成
1) Store： 保存整个程序的状态或对象树。
2) Action：它本质上就是一个简单的JS对象，它内部必须要有一个type的属性，用来表示将要执行的动作。
3) Reducer：主要用于响应发送过来的action，处理完数据后把最新的state数据返回。


## 43. 解释 Reducer 的作用
Reducer是纯函数，接受先前的state和 action ，根据操作的类型确定需要执行哪种更新，然后返回一个新的状态。
## 44. 什么是纯函数？
纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。



 